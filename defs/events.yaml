# Definitions used to identify events searches. Events can be single or
# multi-line and the data source can be a filesystem path or command.
#
# Entries are defined using the following hierarchy:
#
# PLUGIN:
#   GROUP:
#     SECTION:
#       EVENT:
#
# Supported fields (for more details see common.checks.EventChecksBase):
#
# Two types of searches are available here; single line and sequence. A
# sequence can take one of two formats; start/end or start/body/end. Sequence
# endings are optional and if a body is defined this results in
# searchtools.SequenceSearchDef being used otherwise the results are simply
# tagged with -start and -end suffix which can then be processed using
# core.analytics.LogEventStats. If not a sequence then a single
# searchtools.SearchDef pattern is used.
#
# To match single line events use the form:
#
# <label>:
#   expr: <re.match pattern>
#   hint: optional <re.match pattern> used as a low-cost filter
#
# To match multi-line events (sequences) use the form:
#
# <label>:
#   [start|body|end]:
#     expr: <re.match pattern> used to match portion of sequence
#     hint: optional <re.match pattern> used as a low-cost filter
#
# Mandatory fields:
#
#  input: see core.checks.YAMLDefInput
#
#  NOTE: input can specified at the group, section or event level with the
#        latter taking precedence.
#
# Optional fields:
#
#   allow-all-logs: whether to allow path to be wildcarded. The default
#                   is True and should be set to False if searching full
#                   history will result in excessive load or execution time.
#
# TIP: to use a single quote ' inside a yaml string you need to replace it with
#      two single quotes.
#
openstack:
  nova-external-events:
    input:
      type: filesystem
      value: 'var/log/nova/nova-compute.log'
      meta:
        # Searching all logs can yield too many results and we don't yet have a
        # way to override MAX_LOGROTATE_DEPTH so disabling for now.
        allow-all-logs: False
    # Supported events - https://docs.openstack.org/api-ref/compute/?expanded=run-events-detail#create-external-events-os-server-external-events  # noqa E501
    events:
      network-changed:
        expr: '.+\[instance: (\S+)\].+Received event (network-changed)-(\S+)\s+'
      network-vif-plugged:
        expr: '.+\[instance: (\S+)\].+Preparing to wait for external event (network-vif-plugged)-(\S+)\s+'
  nova-checks:
    input:
      type: filesystem
      value: 'var/log/nova/nova-compute.log'
    warnings:
      pci-dev-not-found:
        expr: '^([0-9\-]+) (\S+) .+ No net device was found for VF \S+: nova.exception.PciDeviceNotFoundById: PCI device (\S+) not found'
        hint: 'WARNING'
  neutron-agent-checks:
    neutron-ovs-agent:
      input:
        type: filesystem
        value: 'var/log/neutron/neutron-openvswitch-agent.log'
        meta:
          # Disabling all-logs for now since running against a long
          # history of logs can generate a very large amount of data that can
          # consume too much memory.
          allow-all-logs: False
      # identify rpc_loop iterations and get stats and longest running loops.
      rpc-loop:
        start:
          expr: '^([0-9\-]+) (\S+) .+ Agent rpc_loop - iteration:([0-9]+) started.*'
          hint: 'Agent rpc_loop'
        end:
          expr: '^([0-9\-]+) (\S+) .+ Agent rpc_loop - iteration:([0-9]+) completed..+'
          hint: 'Agent rpc_loop'
    neutron-l3-agent:
      input:
        type: filesystem
        value: 'var/log/neutron/neutron-l3-agent.log'
      # identify router updates that took the longest to complete and report the longest updates.
      router-updates:
        start:
          expr: '^([0-9-]+) (\S+) .+ Starting router update for (\S+), .+ update_id (\S+). .+'
          hint: 'router update'
        end:
          expr: '^([0-9-]+) (\S+) .+ Finished a router update for (\S+), update_id (\S+). .+'
          hint: 'router update'
      # identify HA router keepalived spawn events that took the longest to complete and report the longest updates.
      router-spawn-events:
        # router state_change_monitor + keepalived spawn
        start:
          expr: '^([0-9-]+) (\S+) .+ Router (\S+) .+ spawn_state_change_monitor'
          hint: 'spawn_state_change'
        end:
          expr: '^([0-9-]+) (\S+) .+ Keepalived spawned with config \S+/ha_confs/([0-9a-z-]+)/keepalived.conf .+'
          hint: 'Keepalived'
  neutron-router-checks:
    l3ha:
      vrrp-transitions:
        input:
          type: command
          value: journalctl
          meta:
            args-callback: journalctl_args
        expr: '^([0-9-]+)T\S+ \S+ Keepalived_vrrp\[\d+\]: (?:VRRP_Instance)?\(VR_(\d+)\) .+ (\S+) STATE'
  octavia-checks:
    octavia-health-manager:
      input:
        type: filesystem
        value: 'var/log/octavia/octavia-health-manager.log'
      amp-missed-heartbeats:
        expr: '^(\S+) \S+ .+ Amphora (\S+) health message was processed too slowly:.+'
        hint: 'Amphora'
      lb-failover-auto:
        expr: '^(\S+) \S+ .+ Performing failover for amphora:\s+(.+)'
        hint: 'failover'
    octavia-worker:
      lb-failover-manual:
        input:
          type: filesystem
          value: 'var/log/octavia/octavia-worker.log'
        expr: '^(\S+) \S+ .+ Performing failover for amphora:\s+(.+)'
        hint: 'failover'
  apparmor-checks:
    input:
      type: filesystem
      value: 'var/log/kern.log'
    denials:
      nova:
        expr: '(\S+ \d+) \d+:\S+\s+.+apparmor="DENIED".+\s+profile="(\S+nova\S+)"\s+.+'
        hint: 'apparmor'
      neutron:
        expr: '(\S+ \d+) \d+:\S+\s+.+apparmor="DENIED".+\s+profile="(\S+neutron\S+)"\s+.+'
        hint: 'apparmor'
openvswitch:
  daemon-checks:
    vswitchd:
      input:
        type: filesystem
        value: 'var/log/openvswitch/ovs-vswitchd.log'
      netdev-linux-no-such-device:
        expr: '([0-9-]+)T[0-9:\.]+Z.+\|(\S+): .+ \S+: No such device'
      bridge-no-such-device:
        expr: '([0-9-]+)T[0-9:\.]+Z.+\|could not open network device (\S+) \(No such device\)'
      ovs-thread-unreasonably-long-poll-interval:
        expr: '([0-9-]+)T[0-9:\.]+Z.+\|timeval\(([a-zA-Z]+)(\d+)\)|WARN|Unreasonably long (\d+)ms poll interval'
      rx-packet-on-unassociated-datapath-port:
        expr: '([0-9-]+)T[0-9:\.]+Z.+\|received packet on unassociated datapath port (\d+)'
      receive-tunnel-port-not-found:
        expr:
          - '([0-9-]+)T[0-9:\.]+Z.+\|receive tunnel port not found \((\w+),'
    errors-and-warnings:
      ovs-vswitchd:
        input:
          type: filesystem
          value: 'var/log/openvswitch/ovs-vswitchd.log'
        expr: '([0-9-]+)T[0-9:\.]+Z.+\|(ERR|ERROR|WARN)\|.+'
        hint: '(ERR|WARN)'
      ovsdb-server:
        input:
          type: filesystem
          value: 'var/log/openvswitch/ovsdb-server.log'
        expr: '([0-9-]+)T[0-9:\.]+Z.+\|(ERR|ERROR|WARN)\|.+'
        hint: '(ERR|WARN)'
  flow-checks:
    datapath:
      packet-drops:
        input:
          type: command
          value: ovs_appctl_dpctl_show
          meta:
            kwargs:
              datapath: 'system@ovs-system'
        start: '\s+port \d+: (\S+) .+'
        body: '\s+([RT]X) \S+:(\d+) \S+:(\d+) \S+:(\d+) \S+:(\d+) \S+:(\d+)'
kernel:
  kernlog:
    input:
      type: filesystem
      value: 'var/log/kern.log'
    common:
      stacktrace:
        expr: '.*Call Trace:'
        hint: 'Call'
    memory:
      oom-killer-invoked:
        expr: '(.+ \d+) (\d+:\d+:\d+) .+ (\S+) invoked oom-killer\:'
        hint: 'oom'
    network:
      over-mtu-dropped-packets:
        expr: '.+\] (\S+): dropped over-mtu packet'
        hint: 'dropped'
      nf-conntrack-full:
        expr: '.+ nf_conntrack: table full, dropping packet'
        hint: 'conntrack'
rabbitmq:
  cluster-checks:
    input:
      type: filesystem
      value: 'var/log/rabbitmq/rabbit@*.log'
    rabbitlog:
      cluster-partitions:
        expr: '.+ \S+_partitioned_network'
        hint: 'partition'
  synced-queues:
    input:
      type: filesystem
      value: 'var/log/rabbitmq/rabbit@*.log'
    rabbitlog:
      no-sync:
        expr: 'Mirrored queue ''.+'' in vhost ''.+'': Stopping'
        hint: 'synchronised'
      discard:
        expr: 'Discarding message.+old incarnation'
        hint: 'Discarding'
storage:
  ceph:
    cephlogs:
      input:
        type: filesystem
        value: 'var/log/ceph/ceph*.log'
      osd-reported-failed:
        expr: '^([0-9-]+)\S* \S+ .+ (osd.[0-9]+) reported failed by osd.[0-9]+'
        hint: 'reported failed'
      mon-elections-called:
        expr: '^([0-9-]+)\S* \S+ .+ (mon.\S+) calling monitor election'
        hint: 'calling monitor election'
      slow-requests:
        expr: '^([0-9-]+)\S* \S+ .+ ([0-9]+) slow requests are blocked .+ \(REQUEST_SLOW\)'
        hint: 'REQUEST_SLOW'
      crc-err-bluestore:
        expr: '^([0-9-]+)\S* .+ _verify_csum bad .+'
        hint: '_verify_csum'
      crc-err-rocksdb:
        expr: '^([0-9-]+)\S* .+ rocksdb: .+block checksum mismatch'
        hint: 'checksum mismatch'
      long-heartbeat-pings:
        expr: '^([0-9-]+)\S* \S+ .+ Long heartbeat ping times on \S+ interface seen'
        hint: 'Long heartbeat ping'
      heartbeat-no-reply:
        expr: '^([0-9-]+)\S* \S+ \S+ \S+ osd.[0-9]+ .+ heartbeat_check: no reply from [0-9.:]+ (osd.[0-9]+)'
        hint: 'heartbeat_check'
